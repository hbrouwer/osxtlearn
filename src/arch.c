/*
        arch.c

        David Spitz, spitz@crl.ucsd.edu

Synopsis:
        Generic architecture algorithms for displaying
        network architectures on screen.

General Description:
        These functions are used to display a number of different
        interpretations of the network generated by tlearn.
        The first, known as the architecture or specification
        display, displays a conceptualized rendering of the
        network model - nodes and their connections, in other
        words. The second, called the activations display, is
        a variation on Hinton activations displays which allows
        the user to view the activations of individual nodes
        given a certain network context (usually in the form
        of applied input). The third and final display is the
        weights display, which is also a derivative of Hinton
        diagrams; this display allows the user to observe graphically
        the connection strengths between nodes.

        Two significant modifications have been made to the original
        tlearn code to simplify the heuristics for displaying these
        architectures: the addition of "slabs" and "layers".
        Slabs and Layers are collections of nodes and are used
        to specify node groupings. Layers are always drawn on
        different levels of the network - hence the name "layers".
        The user may specify any number of layers. Slabs, on
        the other hand, are always drawn on the same layer
        as other slabs whose nodes are in the same layer - in
        other words, slabs are used to separate nodes in the
        same layer into groups. Think of layers as inter-layer and
        slabs as intra-layer.
        
        -D.S.


*/

        /* We only compile this code if we have a graphical interface... */

#if defined (XTLEARN) || defined (__QUICKDRAW__)

#include <stdlib.h>
#include <string.h>
#include "general.h"
#include "error.h"
#include "arch.h"

/*
 * This code is used in the X and Mac versions.  The header 
 * requirements are different for each.   
 */

#ifdef XTLEARN  /* X headers */
#include "xtlearnArchGlue.h"
#include "xtlearnArchDisp.h"
#include "xtlearnActDisp.h"
#include "xtlearnWtsDisp.h"

#else         /* Mac header */
#include "MacTlearnArchGlue.h"
#endif

extern CFStruct **cinfo; 

extern int ni; 
extern int nn; 
extern int no; 

extern float **wt; 

extern int *outputs; 

extern float *zold;     /* Holds our node activations. */

Node    *network_nodes= NULL;                   /* This baby holds our network information. */

int     input_node_count,                       /* Number of input nodes. */
        output_node_count,                      /* Number of output nodes. */
        total_node_count,                       /* Total number of nodes. */
        total_layers_in_network,                /* Total number of layers in network. */
        total_slabs_in_network,                         /* Total number of slabs in nework. */
        show_bias_node= 0,                      /* Do we draw bias node? */
        show_node_numbers= 1,                   /* Do we label nodes? */
        show_slabs= 1,                          /* Do we draw slabs? */
        show_arrowheads= 1,                     /* Do we draw arrow_heads? */
        arch_orientation= ARCHITECTURE_VERTICAL, 
        activations_display_is_open= 0,         /* Is activations display open? */
        weights_display_is_open= 0,             /* Is weights display open? */
        architecture_display_is_open= 0,        /* Is specification display open? */
        next_input_layer,                       /* What layer to use as next input layer. */
        next_hidden_layer,                      /* What layer to use as next hidden layer. */
        next_output_layer,                      /* What layer to use as next output layer. */
        next_new_slab,                          /* What slab to use as next slab? */
        square_size_x,                          /* Width of weights display node. */
        square_size_y;                          /* Height of weights display node. */


char    message[128];                           /* Generic string used for user messages. */

static int map_arch_to_screen(Node *nodes, int width, int height);
static int how_many_nodes_in_layer(Node *nodes, int layer, int *node_array);
static int how_many_nodes_in_slab(Node *nodes, int slab, int *node_array);
static int kill_empty_layers(void);
static int kill_empty_slabs(void);
static int slabs_are_fully_connected(Node *nodes, int source_slab, int target_slab, int *recurrent);
static int draw_resolved_connection(Node *nodes, int source_slab, int target_slab, int recurrent);
static int draw_connection(Node *from_node, Node *to_node, int resolved, int recurrent);
static int draw_architecture(Node *nodes, int which_display);
static int get_slab_dimensions(Node *nodes, int slab, 
                                int *slab_x, int *slab_y, 
                                int *slab_width, int *slab_height, 
                                int *node_count, int *node_type, 
                                int *start_node);

static void draw_boundary_around_slab(Node *nodes, int slab);
static void convert_architecture_from_tlearn(void);



        /* Allocates and loads network into our
           structure. This function assumes that
           the network exists in Tlearn memory, 
           i.e., that the connection matrix is
           set and so forth. In fact, all that
           changes in the structure from hereafter
           is the node positioning and the creation
           of slabs and layers. Therefore, this function
           must be called during configuration file
           parsing, after the architecture is parsed, 
           but before the SPECIAL: section is parsed, 
           since that's where slabs and layers are
           indicated. */
int prepare_architecture_memory(int node_count)
{

    input_node_count        = ni; /* These are from Tlearn. */
    output_node_count       = no; 
    total_node_count        = ni + nn + 1; /* Include bias node. */

    total_layers_in_network = 3; /* Start with three layers. */
    next_input_layer        = 1; 
    next_hidden_layer       = 2; 
    next_output_layer       = 3; 

    total_slabs_in_network= 4;  /* Start with four slabs - */
    next_new_slab= 4;           /* remember bias has its own slab. */

    /* First, deallocate anything we may have from before. */
    if (network_nodes!=NULL) free(network_nodes); 

    /* Now, allocate node memory: */
    network_nodes= (Node *)calloc(total_node_count, sizeof(Node));
    if (network_nodes == NULL) return memerr("network_nodes"); 

    /* Translate tlearn matrices into architecture information; 
       here's where we expect the network to have already been
       loaded into Tlearn memory. */
    convert_architecture_from_tlearn();
    return NO_ERROR; 
}



        /* Given an architecture display ("which_display"), calls
           the appropriate functions to display the architecture.
           "which_display" can be either SPECIFICATION (draw the
           architecture using nodes and connections), ACTIVATIONS
           (draw the nodes and their activations), or WEIGHTS
           (draw the connection matrix and the relative weight
           strengths). */   /* Really a dorky function */

int display_architecture(int which_display)
{
    if (network_nodes == NULL)
        return report_condition("Attempt to display undefined architecture.", 2);

    if (which_display == SPECIFICATION)
        if (map_arch_to_screen(network_nodes, ArchDispWidth(), ArchDispHeight()))
            return ERROR; 

    if (which_display == ACTIVATIONS)
        if (map_arch_to_screen(network_nodes, ActDispWidth(), ActDispHeight()))
            return ERROR; 

    if (draw_architecture(network_nodes, which_display))
        return ERROR; 

    return NO_ERROR; 
}




        /* Using Tlearn supplied information about
           the number of nodes, this function initializes
           the XTlearn network structure into a standard, 
           three-layer, four-slab network (the bias is in
           its own slab), ready for mapping to screen points. */

static void convert_architecture_from_tlearn(void)
{
    int node_is_an_output;      /* Flags an output node */
    int i, j; 

    /* First, set up our omni-present bias node: */
    network_nodes[0].layer= 0; 
    network_nodes[0].slab= 0; 
    network_nodes[0].kind= BIAS_NODE; 

    /* Now go through remaining nodes... */
    for (i=1; i < total_node_count; i++) {
        network_nodes[i].id= i; 
        /* If the node is an input node... */
        if (i <= input_node_count) {
            network_nodes[i].layer= 0; 
            network_nodes[i].slab= 1; 
            network_nodes[i].kind= INPUT_NODE; 
        }
        else {
            node_is_an_output= 0; 
            /* Find out if node is an output node... */
            for (j= 0; j < output_node_count; j++) {
                if (outputs[j] == (i-input_node_count))
                    node_is_an_output= 1; 
            }
            /* If the node is a hidden node... */
            if (!node_is_an_output) {
                network_nodes[i].layer= 1; 
                network_nodes[i].slab= 2; 
                network_nodes[i].kind= HIDDEN_NODE; 
            }
            /* If the node is an output node... */
            else {
                network_nodes[i].layer= 2; 
                network_nodes[i].slab= 3; 
                network_nodes[i].kind= OUTPUT_NODE; 
            }
        }
    }
}








        /* Maps a converted network to window-absolute coordinates given width
           and height of display bounding rectangle, and network
           arch_orientation. Coordinates assume an origin of 0, 0, in the
           upper left corner; drawing routines must modify window coordinates
           if this is not standard. */

static int map_arch_to_screen(Node *nodes, int width, int height)
{
    int
        layer_size_x,           /* Width of layer. */
        layer_size_y,           /* Height of layer. */
        x_increment,            /* Horizontal distance between layers. */
        y_increment,            /* Vertical distance between layers. */
        layer_center_x,         /* Horizontal center of layer. */
        layer_center_y,         /* Vertical center of layer. */
        offset_x,               /* Horizontal offset of current node. */
        offset_y,               /* Vertical offset of current node. */
            
        *nodes_in_layer,        /* List of nodes in particular layer. */
        number_of_nodes_in_this_layer, /* Number of nodes in particular layer. */
        layer,                  /* Loop variable. */
        node;                   /* Loop variable. */

    float
        node_space_x,           /* Horizontal distance between nodes. */
        node_space_y,           /* Vertical distance between nodes. */
        current_node_x,         /* Current node's x-coordinate. */
        current_node_y;         /* Current node's y-coordinate. */


    if (arch_orientation == ARCHITECTURE_VERTICAL) {
        layer_size_x= width; 
        layer_size_y= height / total_layers_in_network; 
        x_increment= 0; 
        y_increment= layer_size_y; 
    }
    else {
        layer_size_x= width / total_layers_in_network; 
        layer_size_y= height; 
        x_increment= layer_size_x; 
        y_increment= 0; 
    }

    /* Find center of general layer: */
    layer_center_x= layer_size_x / 2; 
    layer_center_y= layer_size_y / 2; 
    offset_x= 0; 
    offset_y= 0; 

    nodes_in_layer= (int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_layer == NULL) return memerr("nodes_in_layer");

    for (layer= 0; layer < total_layers_in_network; layer++) {
        number_of_nodes_in_this_layer=
            how_many_nodes_in_layer(nodes, layer, nodes_in_layer); 

        if (number_of_nodes_in_this_layer == ERROR) return ERROR; 

        if (arch_orientation == ARCHITECTURE_VERTICAL) {
            /* The +1 is because if we have, say, 5 nodes, 
               we want to have six regions so they are centered. */
            node_space_x= (float)layer_size_x /
                (float)(number_of_nodes_in_this_layer+1); 
            node_space_y= 0.; 
            current_node_x= (float)node_space_x; 
            current_node_y= (float)layer_center_y; 
        }
        else {
            node_space_x= 0.; 
            /* The +1 is because if we have, say, 5 nodes, 
               we want to have six regions so they are centered. */
            node_space_y= (float)layer_size_y /
                (float)(number_of_nodes_in_this_layer+1); 
            current_node_x= (float)layer_center_x; 
            current_node_y= (float)node_space_y; 
        }
        current_node_x += offset_x; 
        current_node_y += offset_y; 
        for (node= 0; node < number_of_nodes_in_this_layer; node++) {
            nodes[nodes_in_layer[node]].x= (int)current_node_x; 
            nodes[nodes_in_layer[node]].y= (int)((int)height - (int)current_node_y); 
            current_node_x= ((float)current_node_x + (float)node_space_x); 
            current_node_y= ((float)current_node_y + (float)node_space_y); 
        }
        offset_x += x_increment; 
        offset_y += y_increment; 
    }
    free(nodes_in_layer); 

    return NO_ERROR; 
}








        /* Returns the number of nodes in a given layer, as
           well as an array holding the indeces of the actual
           nodes found in that layer. */

static int how_many_nodes_in_layer(Node *nodes, int layer, int *node_array)
{
    int total_nodes= 0;         /* Count of nodes so far. */
    int i; 

    if (node_array == NULL) 
        return report_condition("NULL node_array to how_many_nodes_in_layer().", FATAL_ERROR); 

    for (i= 0; i < total_node_count; i++) {
        if (nodes[i].layer == layer) {
            if (nodes[i].kind == BIAS_NODE) {
                if (show_bias_node) node_array[total_nodes++]= i; 
            }
            else node_array[total_nodes++]= i; 
        }
    }

    return total_nodes; 
}







        /* Returns the number of nodes in a given slab, 
           as well as an array of the indeces of the nodes
           actually found in that slab. */

static int how_many_nodes_in_slab(Node *nodes, int slab, int *node_array)
{
    int i, total_nodes= 0;      /* Total nodes so far. */

    if (node_array == NULL)
        return report_condition("NULL node_array to how_many_nodes_in_slab().", FATAL_ERROR); 
    for (i= 0; i < total_node_count; i++) {
        if (nodes[i].slab == slab) {
            if (nodes[i].kind == BIAS_NODE) {
                if (show_bias_node) {
                    node_array[total_nodes++]= i; 
                }
            }
            else {
                node_array[total_nodes++]= i; 
            }
        }
    }
    return total_nodes; 
}




        /* Draws specified architecture display at pre-mapped
           points. */

static int draw_architecture(Node *nodes, int which_display)
{
    int *nodes_in_source_slab,  /* Arrays to hold node index lists. */
        *nodes_in_target_slab, 
        number_of_nodes_in_source_slab, /* Node count variables. */
        number_of_nodes_in_target_slab, 
        recurrent,              /* Flag for recurrent connected. */
        display_height, 
        x, y,                   /* WEIGHTS display coordinate variables. */
        i, j, k, m; 

    float
        biggest_weight, 
        biggest_activation, 
        temp; 

    nodes_in_source_slab= (int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_source_slab == NULL) return memerr("nodes_in_source_slab");

    nodes_in_target_slab= (int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_target_slab == NULL) return memerr("nodes_in_target_slab");

    switch(which_display) {
        case SPECIFICATION:
            if (!show_slabs) {
                for (i= (1 -show_bias_node); i < input_node_count+1; i++) 
                    draw_node((Node *)&nodes[i], which_display, 0.0, 0.0); 

                for (i=input_node_count+1; i < total_node_count; i++) {
                    draw_node((Node *)&nodes[i], which_display, 0.0, 0.0); 
                    for (j= (1 -show_bias_node); j < total_node_count; j++) {
                        if (cinfo[i-input_node_count-1][j].con) {
                            if (draw_connection((Node *)&nodes[j], (Node *)&nodes[i], 
                                                NORMAL_CONNECTION, 
                                                cinfo[i-input_node_count-1][j].rec))
                                return ERROR; 
                        }
                    }
                }
            }
            else {
                /* Draw each slab and the resolved connections. Any slabs which
                   share connections but which are not fully connected will
                   have those connections drawn as normal connection (ie, not
                   thick connections). */
                for (i= 0; i < total_slabs_in_network; i++) {
                    for (j= 0; j < total_slabs_in_network; j++) {
                        if (slabs_are_fully_connected(nodes, i, j, &recurrent)) {
                            if (draw_resolved_connection(nodes, i, j, recurrent))
                                return ERROR; 
                        }
                        else {  /* Draw any individual connections. */
                            number_of_nodes_in_source_slab=
                                how_many_nodes_in_slab(nodes, i, 
                                                       nodes_in_source_slab); 
                            number_of_nodes_in_target_slab=
                                how_many_nodes_in_slab(nodes, j, 
                                                       nodes_in_target_slab); 
                            for (k= 0; k < number_of_nodes_in_source_slab; k++) {
                                for (m= 0; m < number_of_nodes_in_target_slab; m++) {
                                    if (nodes_in_target_slab[m] -input_node_count-1 > 0) {
                                        if (cinfo[ nodes_in_target_slab[m]
                                                  -input_node_count-1]
                                            [nodes_in_source_slab[k]].con) {
                                            if (draw_connection((Node *)&nodes[ nodes_in_source_slab[k]], 
                                                                (Node *)&nodes[ nodes_in_target_slab[m]], 
                                                                NORMAL_CONNECTION, 
                                                                cinfo[nodes_in_target_slab[m]
                                                                      -input_node_count-1]
                                                                [nodes_in_source_slab[k]].rec))
                                                return ERROR; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                /* Draw slabs (as rectangles): */
                for (i= 0; i < total_slabs_in_network; i++)
                    draw_boundary_around_slab(nodes, i);
            }

        break; 

        case ACTIVATIONS:
            biggest_activation= 0.001; /* prevents divide by zero */
 
            for (i= (1 -show_bias_node); i < total_node_count; i++) {
                temp= zold[i]; 
                if (temp < 0.0) temp= -temp; /* absolute value, basically. */
                if (temp > biggest_activation) biggest_activation= temp; 
            }
        
            for (i= (1 -show_bias_node); i < total_node_count; i++) 
                draw_node((Node *)&nodes[i], 
                          which_display, 
                          zold[i], 
                          biggest_activation); 
            break; 

        case WEIGHTS:
            biggest_weight= 0.001;  /* prevents divide by zero */
            for (i= 0; i < total_node_count -input_node_count -1; i++) {
                for (j= 0; j < total_node_count; j++) {
                    if (cinfo[i][j].con) {
                        temp= wt[i][j]; 
                        if (temp < 0.0) temp= -temp; 
                        if (temp > biggest_weight) biggest_weight= temp; 
                    }
                }
            }

            display_height= WtsDispHeight();; 

            square_size_x= (WtsDispWidth() -DISPLAY_MARGIN *6)/total_node_count; 
            square_size_y= (display_height -DISPLAY_MARGIN *5)/(total_node_count-input_node_count-1); 
            y= DISPLAY_MARGIN;
            for (i= 0; i < total_node_count-input_node_count-1; i++) {
                x= DISPLAY_MARGIN *5;
                weights_disp_label(i +1, DISPLAY_MARGIN, y +square_size_y/2, 0);
                for (j= 0; j < total_node_count; j++) {
                    if (cinfo[i][j].con) 
                        draw_weight_box(wt[i][j], biggest_weight, x, y); 
                    if (i == 0) {
                        if (j <= input_node_count) /* input/bias node */
                            weights_disp_label(j, x +square_size_x/2, display_height -DISPLAY_MARGIN, 1);
                        else
                            weights_disp_label(j-input_node_count, x +square_size_x/2, display_height -DISPLAY_MARGIN, 0);
                    }
                    x += square_size_x; 
                }
                y += square_size_y; 
            }
            break; 
    }

    free(nodes_in_target_slab); 
    free(nodes_in_source_slab); 
    return NO_ERROR; 
}





     /* Put given nodes in a new layer. */

int make_new_layer(int *node_array)
{
    int next_new_layer,         /* Where to add our nodes. */
        first_node= 0,          /* First node in list. */
        i; 

    if (network_nodes == NULL) 
        report_condition("make_new_layer() attempted on NULL architecture.", 3);
        
    /* We need to determine if the nodes we've been passed
       are input, hidden, or output nodes so that we know where
       to insert them. This is also an error checking facility. */

    while(!node_array[first_node]) first_node++; 

    switch(network_nodes[first_node].kind) {
        case BIAS_NODE:
            return report_condition("Can't put bias in layer.", 2); 
        case INPUT_NODE:
            next_new_layer= next_input_layer; 
            for (i= first_node; i < total_node_count; i++)
                if (node_array[i]&&(network_nodes[i].kind!=INPUT_NODE)) 
                    return report_condition("You've specified more than just input nodes in a layer.", 2); 

            next_input_layer++; 
            next_hidden_layer++; 
            next_output_layer++; 
            break; 

        case HIDDEN_NODE:
            next_new_layer= next_hidden_layer; 
            for (i= first_node; i < total_node_count; i++) 
                if (node_array[i] && (network_nodes[i].kind != HIDDEN_NODE))
                    return report_condition("You've specified more than just hidden nodes in a layer.", 2); 

            next_hidden_layer++; 
            next_output_layer++; 
            break; 

        case OUTPUT_NODE:
            next_new_layer= next_output_layer; 
            for (i= first_node; i < total_node_count; i++)
                if (node_array[i] && (network_nodes[i].kind != OUTPUT_NODE))
                    return report_condition("You've specified more than just output nodes in a layer.", 2); 

            next_output_layer++; 
            break; 
        default:
            return report_condition("Unknown node kind in make_new_layer().", FATAL_ERROR); 
            break; 
        }

    /* Since we're inserting nodes, we need to "push up" any nodes which are
       currently above our insertion point... */
    for (i= 0; i < total_node_count; i++) {
        if (network_nodes[i].layer >= next_new_layer) {
            network_nodes[i].layer++; /* push up. */
        }
    }


    /* Now we actually insert the node by changing its layer field: */
    for (i= 0; i < total_node_count; i++) {
        if (node_array[i]) {
            network_nodes[i].layer= next_new_layer; 
        }
    }

    total_layers_in_network++; 

    /* All layers are by definition slabs, so make a slab out of the nodes: */
    if (make_new_slab(node_array))
        return report_condition("node_array passed make_new_layer but failed make_new_slab.", FATAL_ERROR); 

    /* Finally, we kill any layers which may have been
       emptied by the above process, since we only
       want to display layers which contain at least
       one node. */
    kill_empty_layers(); 
    return NO_ERROR; 
}




        /* Puts given nodes into a new slab. */

int make_new_slab(int *node_array)
{
    int i, first_node= 0;       /* First node in list. */

    if (network_nodes == NULL) 
        report_condition("New slab attempt on unprepared architecture.", FATAL_ERROR); 

    while(!node_array[first_node]) first_node++; 

    switch(network_nodes[first_node].kind) {
        case BIAS_NODE:
            return report_condition("Can't put bias in slab.", 2); 
            break; 
        case INPUT_NODE:
            for (i=first_node; i < total_node_count; i++)
                if (node_array[i]&&(network_nodes[i].kind!=INPUT_NODE))
                    return report_condition("You've specified more than just input nodes in a slab.", 2); 
            break; 
        case HIDDEN_NODE:
            for (i=first_node; i < total_node_count; i++)
                if (node_array[i]&&(network_nodes[i].kind!=HIDDEN_NODE))
                    return report_condition("You've specified more than just hidden nodes in a slab.", 2); 
            break; 
        case OUTPUT_NODE:
            for (i=first_node; i < total_node_count; i++)
                if (node_array[i]&&(network_nodes[i].kind!=OUTPUT_NODE))
                    return report_condition("You've specified more than just output nodes in a slab.", 2); 
            break; 
        default:
            return report_condition("Unknown node type in make_new_slab().", FATAL_ERROR); 
            break; 
        }

    /* Put nodes into new slab: */
    for (i= 0; i < total_node_count; i++) {
        if (node_array[i]) {
            network_nodes[i].slab= next_new_slab; 
        }
    }
    next_new_slab++; 
    total_slabs_in_network++; 

    /* Kill any slabs we may have emptied... */
    kill_empty_slabs(); 

    return NO_ERROR; 

}


       /* Remove layers containing no nodes. */

static int kill_empty_layers(void)
{
    int *nodes_in_layer, node_count, i, j; 

    nodes_in_layer=(int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_layer == NULL) return memerr("nodes_in_layer");

    for (i= 0; i < total_layers_in_network; i++) {
        node_count= how_many_nodes_in_layer(network_nodes, i, nodes_in_layer); 
        if (node_count == 0) {
            for (j= 0; j < total_node_count; j++) {
                if (network_nodes[j].layer > i) network_nodes[j].layer--; 
            }
            total_layers_in_network--; 
            if (next_input_layer > i) {
                next_input_layer--; 
            }
            if (next_hidden_layer > i) {
                next_hidden_layer--; 
            }
            if (next_output_layer > i) {
                next_output_layer--; 
            }
        }
    }
    return NO_ERROR; 
}






        /* Remove slabs containing no nodes. */

static int kill_empty_slabs(void)
{
    int *nodes_in_slab, node_count, i, j; 
        
    nodes_in_slab=(int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_slab == NULL) return memerr("kill_empty_slab()"); 

    for (i= 0; i < total_slabs_in_network; i++) {
        node_count= how_many_nodes_in_slab(network_nodes, i, nodes_in_slab); 
        if (node_count == 0) {
            for (j= 0; j < total_node_count; j++) {
                if (network_nodes[j].slab > i) network_nodes[j].slab--; 
            }
            total_slabs_in_network--; 
            next_new_slab--; 
        }
    }
    return NO_ERROR; 
}








        /* If the two given slabs are fully connected, returns non-zero, 
           otherwise returns zero. In addition, if any of the connections
           between the slabs are recurrent, the recurrent flag is also
           made non-zero. */

static int slabs_are_fully_connected(Node *nodes, int source_slab, int target_slab, int *recurrent)
{
    int
        *nodes_in_source_slab,  /* Lists of nodes... */
        *nodes_in_target_slab, 
        number_of_nodes_in_source_slab, /* Node count variables. */
        number_of_nodes_in_target_slab, 
                        
        fully_connected= 1,     /* Flag: assumes we are fully
                                   connected unless we see otherwise. */
        there_is_a_recurrent_connection= 0, /* Recurrence flag. */
        i, j; 

    nodes_in_source_slab= (int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_source_slab == NULL) return memerr("nodes_in_source_slab");

    nodes_in_target_slab= (int*)calloc(total_node_count, sizeof(int));
    if (nodes_in_target_slab == NULL) return memerr("nodes_in_target_slab");

    number_of_nodes_in_source_slab=
        how_many_nodes_in_slab(nodes, source_slab, nodes_in_source_slab); 
    number_of_nodes_in_target_slab=
        how_many_nodes_in_slab(nodes, target_slab, nodes_in_target_slab); 

    /* Since we always kill empty slabs, if either of these returns
       zero, it's because one contains the bias node and we have
       bias node viewing turned off. */

    if (number_of_nodes_in_source_slab == 0 || number_of_nodes_in_target_slab == 0) {
        free(nodes_in_source_slab); 
        free(nodes_in_target_slab); 
        *recurrent= 0; 
        fully_connected= 0; 
        return fully_connected; 
    }
        

    /* Go through each node in target_slab, and
       make sure it's connected to each node
       in source_slab: */

    for (i= 0; i < number_of_nodes_in_target_slab; i++) {
        for (j= 0; j < number_of_nodes_in_source_slab; j++) {
            if (nodes_in_target_slab[i]-input_node_count-1 < 0) {
                /* Means there's an input node in the target_slab, which
                   are not valid as target nodes, so we know they're
                   not connected. */
                fully_connected= 0; 
            }
            else if (!cinfo[nodes_in_target_slab[i]-input_node_count-1]
                     [nodes_in_source_slab[j]].con) {
                fully_connected= 0; 
            }
            else if (cinfo[nodes_in_target_slab[i]-input_node_count-1]
                     [nodes_in_source_slab[j]].rec) {
                there_is_a_recurrent_connection= 1; 
            }
            else {
            }
        }
    }
        
    free(nodes_in_source_slab); 
    free(nodes_in_target_slab); 
    *recurrent= there_is_a_recurrent_connection; 
    return fully_connected; 
}




        /* Given a slab, draws the corresponding rectangle. */

static void draw_boundary_around_slab(Node *nodes, int slab)
{
    int
        rect_x,                 /* Coordinates and dimensions of rectangle. */
        rect_y, 
        width, 
        height, 

        node_count,             /* Number of nodes in rectangle. */
        node_type,              /* Type of node in rectangle. */
        start_node;             /* Beginning node in rectangle. */

    get_slab_dimensions(nodes, slab, &rect_x, &rect_y, &width, &height, 
                        &node_count, &node_type, &start_node);

    /* Now that we have coordinates for rectangle, draw it! */
    if (node_count > 0)
        draw_architecture_rectangle(rect_x, rect_y, width, height, 
                                    node_count, node_type, start_node);

}






     /* Returns the dimensions of the given slab. */

static int get_slab_dimensions(Node *nodes, int slab, 
                                int *slab_x, int *slab_y, 
                                int *slab_width, int *slab_height, 
                                int *node_count, int *node_type, int *start_node)
{
    int
        *node_array,            /* List of nodes in slab. */
        number_of_nodes_in_slab, /* Number of nodes in slab. */
        x1,                     /* Coordinates and dimensions of slab. */
        y1, 
        x2, 
        y2, 
        rect_x, 
        rect_y, 
        width, 
        height, 

        divisor= 2;             /* Size divisor. */

    node_array= (int*)calloc(total_node_count, sizeof(int));
    if (node_array == NULL) return memerr("node_array");

    number_of_nodes_in_slab= how_many_nodes_in_slab(nodes, slab, node_array); 
        
    *node_count= number_of_nodes_in_slab; 

    /* Bias slab, don't show it. */
    if (number_of_nodes_in_slab == 0) return 0; 

    /* For single nodes, we need to maintain minimal size of
       slab. */
    if (number_of_nodes_in_slab == 1) divisor= 1; 

    *node_type= nodes[node_array[0]].kind; 
    *start_node= nodes[node_array[0]].id; 

    /* Now, get coord's of first and last node. */
        
    x1= nodes[node_array[0]].x; 
    y1= nodes[node_array[0]].y; 

    x2= nodes[node_array[number_of_nodes_in_slab-1]].x; 
    y2= nodes[node_array[number_of_nodes_in_slab-1]].y; 

    if (arch_orientation == ARCHITECTURE_VERTICAL) {
        if (x2 >= x1) {
            rect_x= x1 - NODE_SIZE/2; 
            rect_y= y1 - NODE_SIZE/2; 
            width= x2-x1+NODE_SIZE/divisor; 
            height= NODE_SIZE; 
        }
        else {                  /* x2 < x1 */
            rect_x= x2 - NODE_SIZE/2; 
            rect_y= y2 - NODE_SIZE/2; 
            width= x1-x2+NODE_SIZE/divisor; 
            height= NODE_SIZE; 
        }
    }
    else {
        if (y2 < y1) {
            rect_x= x2 - NODE_SIZE/2; 
            rect_y= y2 - NODE_SIZE/2; 
            width= NODE_SIZE; 
            height= y1-y2+NODE_SIZE/divisor; 
        }
        else {                  /* y2 >= y1 */
            rect_x= x1 - NODE_SIZE/2; 
            rect_y= y1 - NODE_SIZE/2; 
            width= NODE_SIZE; 
            height= y2-y1+NODE_SIZE/divisor; 
        }
    }

    *slab_x= rect_x; 
    *slab_y= rect_y; 
    *slab_width= width; 
    *slab_height= height; 

    free(node_array); 
    return 0;
}



     /* Given two slabs, which have been determined to be fully connected from one
           to the other, draw the corresponding SINGLE resolved connection. */

static int draw_resolved_connection(Node *nodes, int source_slab, int target_slab, int recurrent)
{
    /* We'll take advantage of code we've already written here. We'll
       use our current connection drawing code, only we'll make up
       two temporary nodes to draw between. One will be in the
       first slab's center, and the second in the target slab's
       center. Then we'll just call our connection drawing routine, 
       which will take care of line thickening and making sure
       the arrow tips don't touch the slabs. */

    Node from_node, to_node;    /* Our temporary "fake" nodes */

    int *source_slab_nodes,
        *target_slab_nodes, 
        source_slab_node_count, 
        target_slab_node_count, 
        x1, 
        y1, 
        x2, 
        y2, 

        same_layer= 0,          /* Are the nodes in the same layer? */

        from_radius,            /* Helps find the endpoints of the slabs. */
        to_radius; 

    source_slab_nodes= (int*)calloc(total_node_count, sizeof(int));
    if (source_slab_nodes == NULL) return memerr("source_slab_nodes");

    target_slab_nodes= (int*)calloc(total_node_count, sizeof(int));
    if (target_slab_nodes == NULL) return memerr("target_slab_nodes");

    source_slab_node_count= how_many_nodes_in_slab(nodes, source_slab, source_slab_nodes); 
    target_slab_node_count= how_many_nodes_in_slab(nodes, target_slab, target_slab_nodes); 

    if (source_slab_node_count <= 0) {
        sprintf(message, "draw_resolved_connection(): source slab (%i) is empty.", 
                source_slab); 
        return report_condition(message, FATAL_ERROR); 
    }
    if (target_slab_node_count <= 0) {
        sprintf(message, "draw_resolved_connection(): target slab (%i) is empty.", 
                target_slab); 
        return report_condition(message, FATAL_ERROR); 
    }

    if (nodes[source_slab_nodes[0]].layer == nodes[target_slab_nodes[0]].layer) {
        if (nodes[source_slab_nodes[0]].slab!=nodes[target_slab_nodes[0]].slab) {
            same_layer= 1; 
        }
    }

    from_radius= NODE_SIZE/2; 
    to_radius= NODE_SIZE/2; 


    /* Get middle of slabs: */
    if (arch_orientation == ARCHITECTURE_VERTICAL) {
        x1= ((nodes[source_slab_nodes[source_slab_node_count-1]].x -
              nodes[source_slab_nodes[0]].x ) / 2) +
                  nodes[source_slab_nodes[0]].x; 
        y1= nodes[source_slab_nodes[0]].y; 
        x2= ((nodes[target_slab_nodes[target_slab_node_count-1]].x -
              nodes[target_slab_nodes[0]].x ) / 2) +
                  nodes[target_slab_nodes[0]].x; 
        y2= nodes[target_slab_nodes[0]].y; 
    }
    else {
        x1= nodes[source_slab_nodes[0]].x; 
        y1= ((nodes[source_slab_nodes[0]].y - 
              nodes[source_slab_nodes[source_slab_node_count-1]].y ) / 2) +
                  nodes[source_slab_nodes[source_slab_node_count-1]].y; 
        x2= nodes[target_slab_nodes[0]].x; 
        y2= ((nodes[target_slab_nodes[0]].y - 
              nodes[target_slab_nodes[target_slab_node_count-1]].y ) / 2) +
                  nodes[target_slab_nodes[target_slab_node_count-1]].y; 
    }


    /* Preserve all other nodal information: */
    memcpy((void *)&from_node, (void *)&(nodes[source_slab_nodes[0]]), sizeof(Node)); 
    memcpy((void *)&to_node, (void *)&(nodes[target_slab_nodes[0]]), sizeof(Node)); 

    /* Set coordinates of our fake nodes. */
    from_node.x= x1; 
    from_node.y= y1; 
    to_node.x= x2; 
    to_node.y= y2; 

    /* Draw the connection! */
    if (draw_connection((Node *)&from_node, (Node *)&to_node, RESOLVED_CONNECTION, recurrent))
        return ERROR; 

    free(source_slab_nodes); 
    free(target_slab_nodes); 

    return NO_ERROR; 
}



        /* Draws a connection from one node to another. There
           are four cases. First is the normal connection, which is
           simple a straight line. Then there are self, high-to-low, 
           and low-to-high connections, each of which implies that
           the nodes to be connected are level, that is to say, in
           the same layer. These connections must therefore be
           curved so that they are not obscured. Lengthy code here. */

static int draw_connection(Node *from_node, Node *to_node, int resolved, int recurrent)
{
    int 
        from_x,                         /* From, to coordinates. */
        to_x, 
        from_y, 
        to_y, 
        connection_type,        /* Determines curved or not. */
        width,                  /* Spacing stuff... */
        height, 
        connection_width, 
        connection_height, 
        touching_distance_divisor= 2, /* Determines if connections touch
                                         connecting points or not: nodes
                                         are touched, slabs aren't. */
        thickness= THIN_LINE,           /* Recurrent connections are thin. */

        /* Arrowhead stuff: */
        a1_x, 
        a1_y, 
        a2_x, 
        a2_y; 


    if (resolved) {
        thickness= THICK_LINE; 
        touching_distance_divisor= 1; 
    }


    from_x= from_node->x + DISPLAY_MARGIN; 
    from_y= from_node->y + DISPLAY_MARGIN; 
    to_x= to_node->x + DISPLAY_MARGIN; 
    to_y= to_node->y + DISPLAY_MARGIN; 

    /* What type of connection? */
    if (from_node->layer == to_node->layer) {
        if (to_node->id < from_node->id) connection_type= HIGH_TO_LOW_CONNECTION; 
        else if (to_node->id > from_node->id) connection_type= LOW_TO_HIGH_CONNECTION; 
        else connection_type= SELF_CONNECTION; 
    }

    else connection_type= NORMAL_CONNECTION; 


    /* Here, we move the connection endpoints to just at the edge
       of the nodes; otherwise, if we allow them to go all the way
       to the center of the nodes, the arrowheads are obscured by
       the node. If we are using resolved connections, then we actually
       move out extra distance so slabs aren't touched by connections.
       "touching_distance_divisor" accomplishes this feat. */
    if (arch_orientation == ARCHITECTURE_VERTICAL) {
        if (from_y < to_y) {
            from_y += NODE_SIZE/touching_distance_divisor; 
            to_y -= NODE_SIZE/touching_distance_divisor; 
        }
        else if (from_y > to_y) {
            from_y -= NODE_SIZE/touching_distance_divisor; 
            to_y += NODE_SIZE/touching_distance_divisor; 
        }
        else {                  /* indicates same-layer. */
            if (connection_type == HIGH_TO_LOW_CONNECTION) {
                from_y += NODE_SIZE/touching_distance_divisor; 
                to_y += NODE_SIZE/touching_distance_divisor; 
            }
            else {
                from_y -= NODE_SIZE/touching_distance_divisor; 
                to_y -= NODE_SIZE/touching_distance_divisor; 
            }
        }
    }
    else {
        if (from_x < to_x) {
            from_x += NODE_SIZE/touching_distance_divisor; 
            to_x -= NODE_SIZE/touching_distance_divisor; 
        }
        else if (from_x > to_x) {
            from_x -= NODE_SIZE/touching_distance_divisor; 
            to_x += NODE_SIZE/touching_distance_divisor; 
        }
        else {                  /* indicates same-layer. */
            if (connection_type == HIGH_TO_LOW_CONNECTION) {
                from_x -= NODE_SIZE/touching_distance_divisor; 
                to_x -= NODE_SIZE/touching_distance_divisor; 
            }
            else {
                from_x += NODE_SIZE/touching_distance_divisor; 
                to_x += NODE_SIZE/touching_distance_divisor; 
            }
        }
    }




    switch(connection_type) {
        case NORMAL_CONNECTION:
            if (recurrent) architecture_set_line_attributes(thickness, DASHED_LINE); 
            else architecture_set_line_attributes(thickness, SOLID_LINE); 

            if (show_arrowheads) draw_line_arrowhead(from_x, from_y, to_x, to_y, 1); 
            else architecture_draw_line(from_x, from_y, to_x, to_y); 
            
            break; 
        case SELF_CONNECTION:
            if (recurrent) architecture_set_line_attributes(thickness, DASHED_LINE); 
            else architecture_set_line_attributes(thickness, SOLID_LINE); 
            
            if (arch_orientation == ARCHITECTURE_VERTICAL) {
                a1_x= from_x+ARROW_LENGTH; 
                a1_y= from_y-8; 
                a2_x= from_x; 
                a2_y= from_y; 

                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0); 
                architecture_draw_arc(from_x - NODE_SIZE, 
                                      from_y - (NODE_SIZE*2), 
                                      NODE_SIZE * 2, 
                                      NODE_SIZE * 2, 
                                      0, 360*ARC_ANGLE_RESOLUTION); 
            }
            else {
                a1_x =from_x+8; 
                a1_y =from_y+ARROW_LENGTH; 
                a2_x =from_x; 
                a2_y =from_y; 

                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0); 
                architecture_draw_arc(from_x, 
                                      from_y - NODE_SIZE, 
                                      NODE_SIZE * 2, 
                                      NODE_SIZE * 2, 
                                      0, 360*ARC_ANGLE_RESOLUTION); 
            }
            break; 

        case LOW_TO_HIGH_CONNECTION:
            if (recurrent) architecture_set_line_attributes(thickness,DASHED_LINE);
            else architecture_set_line_attributes(thickness,SOLID_LINE);

            width = to_x - from_x;
            height = to_y - from_y;
            if (width<0) width = -width;
            if (height<0) height = -height;
            connection_width = height/CURVE_SCALAR;
            connection_height = width/CURVE_SCALAR;
            if (arch_orientation==ARCHITECTURE_VERTICAL) {
                a1_x =from_x+width-10;
                a1_y =from_y-ARROW_LENGTH;
                a2_x =from_x+width;
                a2_y =from_y;

                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0);
                architecture_draw_arc(from_x,
                                      from_y - (connection_height/2),
                                      width,
                                      connection_height,
                                      0,180*ARC_ANGLE_RESOLUTION);
            }
            else {
                a1_x =from_x+ARROW_LENGTH;
                a1_y =to_y+10;
                a2_x =from_x;
                a2_y =to_y;
                
                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0);
                architecture_draw_arc(to_x-(connection_width/2),
                                      to_y,
                                      connection_width,
                                      height,
                                      270*ARC_ANGLE_RESOLUTION,180*ARC_ANGLE_RESOLUTION);
            }
            break;

        case HIGH_TO_LOW_CONNECTION:
            if (recurrent) architecture_set_line_attributes(thickness,DASHED_LINE);
            else architecture_set_line_attributes(thickness,SOLID_LINE);

            width = to_x - from_x;
            height = to_y - from_y;
            if (width<0) width = -width;
            if (height<0) height = -height;
            connection_width = height/CURVE_SCALAR;
            connection_height = width/CURVE_SCALAR;
            if (arch_orientation==ARCHITECTURE_VERTICAL) {
                a1_x =from_x-width+10;
                a1_y =to_y+ARROW_LENGTH;
                a2_x =from_x-width;
                a2_y =to_y;

                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0);

                architecture_draw_arc(to_x,
                                      to_y - (connection_height/2),
                                      width,
                                      connection_height,
                                      180*ARC_ANGLE_RESOLUTION,180*ARC_ANGLE_RESOLUTION);
            }
            else {
                a1_x =to_x-ARROW_LENGTH;
                a1_y =to_y-10;
                a2_x =to_x;
                a2_y =to_y;
                
                draw_line_arrowhead(a1_x, a1_y, a2_x, a2_y, 0);
                architecture_draw_arc(from_x-(connection_width/2),
                                      from_y,
                                      connection_width,
                                      height,
                                      90*ARC_ANGLE_RESOLUTION,180*ARC_ANGLE_RESOLUTION);
            }
            break;
        }

                /* Go back to normal drawing... */
    architecture_set_line_attributes(THIN_LINE,SOLID_LINE);
    
    return NO_ERROR;
}



#endif



